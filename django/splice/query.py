from django.db.models import Model
from django.splice.splice import SpliceMixin, is_synthesized
from django.splice.identity import empty_taint, union, to_int, to_bitarray
from django.splice import settings
import re
import sqlparse


def inspect_result_cache(cache, qs):
    """
    QuerySet _result_cache caches a list of query results,
    which may contain synthesized data that should not be
    returned to the user.
    """
    print(qs)
    for obj in cache:
        assert isinstance(obj, Model), "_result_cache contains an object of type {} " \
                                       "that is not subclass of Model".format(type(obj))
        for field in obj._meta.fields:
            field_value = getattr(obj, field.name)
            # Checking only tainted/tagged objects in the table
            if isinstance(field_value, SpliceMixin):
                print("inspecting {}: ({}) {}...".format(field.name, type(field_value), field_value))
                if is_synthesized(field_value):
                    print("{value} is a synthesized field and should not "
                          "pass through a trusted sink".format(value=field.name))
            else:
                print("{}: {}".format(field.name, field_value))


def __debug_sql(sql, is_rewrite=False):
    """Format and print an SQL query."""
    formatted_stmt = sqlparse.format(sql, reindent=True, keyword_case='upper', strip_comments=True)
    print("SQL (rewrite: {}):\n{}".format(is_rewrite, formatted_stmt))


def cursor_iter(cursor, sentinel, col_count, itersize):
    """Yield blocks of rows from a cursor"""
    for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
        yield rows if col_count is None else [r[:col_count] for r in rows]


def sql_rewrite_execute(cursor, sql, params, col_count):
    if settings.SPLICE_DEBUG:
        __debug_sql(sql)
    # If the query string contains more than one SQL statement,
    # typically separated by semi-colons, we split it into a
    # list of single statements. We will rewrite the queries one
    # statement at a time. This probably should not happen for SQL
    # queries generated by Django ORM, however.
    # "parsed" contains a list of single statements
    parsed = sqlparse.parse(sql)
    # For simplicity, we do not handle multi-statement cases, and
    # we do not anticipate to handle them at all in Django ORM
    # (i.e., we do not consider raw queries in a Django app here)
    assert len(parsed) == 1, "Cannot handle multi-statement queries"
    stmt = parsed[0]
    # The query must be a SELECT query, or something is wrong
    assert stmt.tokens[0].normalized == 'SELECT', "a SINGLE result query should be a DML query"
    # One or more tokens after stmt.tokens[0] should be whitespace, we skip them
    i = 1
    while stmt.tokens[i].is_whitespace:
        i = i + 1
    # The next non-whitespace token should either be an IdentifierList token, a
    # single Identifier token, or a Function token. Except for Function tokens,
    # we need to make sure they are aggregate operations (to check the case where
    # has_results() in compiler.py is the calling method of execute_sql()). If
    # we see any token that is not an aggregate operation, we do a regular execute
    # and return.
    if type(stmt.tokens[i]) == sqlparse.sql.Function:
        # The token might be just a Function token instead of an Identifier
        # token for aggregation functions like COUNT(). But we will cast it
        # into an Identifier token.
        identifier_token = sqlparse.sql.Identifier([stmt.tokens[i]])
        stmt.tokens[i] = identifier_token
        return sql_rewrite_identifier_execute(cursor, stmt, i, params, col_count)
    elif type(stmt.tokens[i]) == sqlparse.sql.Identifier:
        if type(stmt.tokens[i].tokens[0]) is not sqlparse.sql.Function:
            try:
                cursor.execute(sql, params)
            except Exception:
                # Might fail for server-side cursors (e.g. connection closed)
                cursor.close()
                raise
            try:
                val = cursor.fetchone()
                if val:
                    return val[0:col_count], 0
                return val, 0
            finally:
                # done with the cursor
                cursor.close()
        else:
            return sql_rewrite_identifier_execute(cursor, stmt, i, params, col_count)
    elif type(stmt.tokens[i]) == sqlparse.sql.IdentifierList:
        # We iterate through an IdentifierList token. get_identifiers() returns
        # a generator that skips whitespace and punctuation tokens in IdentifierList.
        for identifier in stmt.tokens[i].get_identifiers():
            if type(identifier.tokens[0]) is not sqlparse.sql.Function:
                try:
                    cursor.execute(sql, params)
                except Exception:
                    # Might fail for server-side cursors (e.g. connection closed)
                    cursor.close()
                    raise
                try:
                    val = cursor.fetchone()
                    if val:
                        return val[0:col_count], 0
                    return val, 0
                finally:
                    # done with the cursor
                    cursor.close()
        return sql_rewrite_identifierlist_execute(cursor, stmt, i, params, col_count)


def sql_rewrite_identifier_execute(cursor, stmt, i, params, col_count, close=True):
    identifier_token = stmt.tokens[i]
    func_token = identifier_token.tokens[0]
    func_name = func_token.tokens[0].value
    # COUNT requires no rewrite, so let's get that out of the way
    if func_name == 'COUNT':
        # No rewrite
        try:
            if settings.SPLICE_DEBUG:
                __debug_sql(str(stmt), True)
            cursor.execute(str(stmt), params)
        except Exception:
            # Might fail for server-side cursors (e.g. connection closed)
            cursor.close()
            raise
        try:
            val = cursor.fetchone()
            if val:
                return val[0:col_count], 0
            return val, 0
        finally:
            # if done with the cursor
            if close:
                cursor.close()
    arg = func_token.tokens[1]  # arg is the argument to func, which should be a Parenthesis token
    arg_identifier = arg.tokens[1]  # actual argument, which should again be an Identifider token
    # The arg_identifier token should be of the form "TABLE_NAME"."COLUMN_NAME", which is a set of 3 tokens
    table_name_token = arg_identifier.tokens[0]
    # new_table_name_token is the same as table_name_token
    new_table_name_token = sqlparse.sql.Token(sqlparse.tokens.String.Symbol, table_name_token.value)
    dot_token = sqlparse.sql.Token(sqlparse.tokens.Punctuation, '.')
    column_name_token = arg_identifier.tokens[2]
    # taint_column_name_token has a new value that is derived from column_name_token's value
    taint_column_name_token = sqlparse.sql.Token(sqlparse.tokens.String.Symbol,
                                                 column_name_token.value[:-1] + '_taint' + '"')
    taint_token = sqlparse.sql.Identifier([new_table_name_token, dot_token, taint_column_name_token])
    # We need to rewrite the query based on the identity of the aggregate function
    if func_name == 'AVG':
        # For AVG, we must run a different query to gather all the taints first
        # The new query replace AVG() to select a taint column instead:
        # SELECT DISTINCT X_taint FROM ...
        stmt.tokens[i] = taint_token
        # Add a DISTINCT keyword token (and whitespace token) in front of the taint column
        whitespace_token = sqlparse.sql.Token(sqlparse.tokens.Punctuation, ' ')
        distinct_token = sqlparse.sql.Token(sqlparse.tokens.Keyword, 'DISTINCT')
        stmt.insert_before(i, whitespace_token)
        stmt.insert_before(i, distinct_token)
        # Execute the new query to get all taints
        try:
            if settings.SPLICE_DEBUG:
                __debug_sql(str(stmt), True)
            cursor.execute(str(stmt), params)
        except Exception:
            # Might fail for server-side cursors (e.g. connection closed)
            cursor.close()
            raise
        # results is a generator that contains all taints that we will union together
        results = cursor_iter(cursor, [], None, 100)
        taints = empty_taint()
        for result in results:
            for res in result:
                taints = union(taints, to_bitarray(res[0]))
        # Now we will execute the original query to get the average result
        stmt.tokens[i] = identifier_token   # The DISTINCT token is replaced by the original AVG() token
        # Because we added a DISTINCT keyword token and an additional whitespace
        # We need to remove some other tokens by setting it to a whitespace token
        stmt.tokens[i + 2] = whitespace_token
        try:
            if settings.SPLICE_DEBUG:
                __debug_sql(str(stmt), True)
            cursor.execute(str(stmt), params)
        except Exception:
            # Might fail for server-side cursors (e.g. connection closed)
            cursor.close()
            raise
        try:
            val = cursor.fetchone()
            if val:
                # val[0] is the AVG result
                return [val[0], to_int(taints)], 1
            return val, 0
        finally:
            # if done with the cursor
            if close:
                cursor.close()
    elif func_name == 'MIN' or  func_name == 'MAX':
        comma_token = sqlparse.sql.Token(sqlparse.tokens.Punctuation, ',')
        # We construct a new IdentifierListo token from taint_token, comma_token, and the original identifier_token
        identifier_list_token = sqlparse.sql.IdentifierList([identifier_token, comma_token, taint_token])
        stmt.tokens[i] = identifier_list_token
        # Execute the new query
        try:
            if settings.SPLICE_DEBUG:
                __debug_sql(str(stmt), True)
            cursor.execute(str(stmt), params)
        except Exception:
            # Might fail for server-side cursors (e.g. connection closed)
            cursor.close()
            raise
        try:
            val = cursor.fetchone()
            if val:
                return val[0:col_count + 1], 1
            return val, 0
        finally:
            # if done with the cursor
            if close:
                cursor.close()
    else:
        NotImplementedError("The aggregate function {} is not implemented".format(func))


def sql_rewrite_identifierlist_execute(cursor, stmt, i, params, col_count):
    extra_col = 0
    vals = list()
    taint_vals = list()
    identifiers = stmt.tokens[i]
    # Generate one query for each identifier
    for identifier in identifiers.get_identifiers():
        stmt.tokens[i] = identifier
        # Do not close the cursor in sql_rewrite_identifier_execute()
        val, col = sql_rewrite_identifier_execute(cursor, stmt, i, params, 1, close=False)
        # val is a tuple of (actual query result, taint result)
        vals.append(val[0])
        taint_vals.append(val[1])
        extra_col += col
    # Combine a list of actual query results (vals) with a list of taint results (taint_vals)
    vals.extend(taint_vals)
    # Done with the cursor now, we can close
    cursor.close()
    return vals, extra_col
